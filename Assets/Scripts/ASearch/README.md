# 基于Unity的AStar（A星寻路算法）

主要功能：生成一个网格地图；通过鼠标输入起点和终点，输出两点间的最（较）短路径。

## AStar算法：

     实现原理
     1、首先有一张一定宽高的地图 （定义好 Point 点的地图，其中 Point 中有 IsWall 属性）
     2、设定开始点，和目标点
     3、传入 FindPath 开始寻找较短路径，找到返回true，否则 false
     4、为 true 就可以通过 目标点的父亲点的父亲点的父亲点，直到父亲点为开始点，这些点集合即是路径
     5、FindPath 寻找原理
     1）开列表，关列表初始化
     2）添加开始点到开列表，然后获得周围点集合，接着又把开始点从开列表中移除，并添加到关列表
     3）判断这些周围点集合是否已经在开列表中，不在则更新这些点的F 和 父亲点，并添加到开列表；再则重新计算G值，G较小则更新GF 和父亲点
     4）从周围点集合中找到 F 最小的点，然后获得周围点集合，接着又把找到 F 最小的点从开列表中移除，并添加到关列表
     5）接着执行第 3） 步骤
     6）直到目标点被添加到开列表中，则路径找到
     7）否则，直到开列表中没有了数据，则说明没有合适路径



A*算法的地图基础，是把地图分成均等的块（点），在这些点组成的集合--地图上做操作。

所以我们把这个算法封装在一个脚本类中，需要用时调用：

有以下方法（具体参数和返回值在脚本中有注释）

	（总）FindPath：取得较短路径；
	     总方法涉及的函数：
	     PointFilter：把关闭列表点，从周围集合过滤
	     GetSurrondPoint：获取当前最小F周围点
	     FindMinOfPoint：开列表所有F，找出最小的F点
	     CalG、CalF：计算G、F；H比较简单，不封装。
	     
	     初始化方法：Init
	     用协程调用此方法：OnStart

## 思路介绍

[所有脚本均有注释，不过多介绍]

1.先实现算法封装；

2.封装Point类继承MonoBehaviour，表示地图上的“点”的属性，可挂载在预制体上；

3.生成网格地图：封装到MapMeshCreate类中；

4.RunTest执行整个项目，主要部分为创建地图，实现事件逻辑；

## 开始使用

1. 准备好地图生成原点：（例：start）、生成挂载脚本的测试物体（也是所有预制体方块的父节点）Test_AStarWrapper

2. 把MapMeshCreate和RunTest挂载到测试物体上。

3. 在MapMeshCreate上设置参数：地图长宽、障碍生成频率、方块模板大小、地图生成原点、父节点、方块预制体；
4. 开始运行，**按下空格随机生成地图**，红色--障碍方块、白色--普通方块；
5. 鼠标点击第一个白块 -- **设置起点**；再点击下一个白块 -- **设置终点**；
6. **按下S键开始寻路**

## Demo展示





# 地图编辑器

主要功能：拓展Unity的编辑器，生成可编辑地图；按下空格后进入连续编辑模式，按下C键进入单个编辑模式；退出编辑模式后将地图纹理生成；

